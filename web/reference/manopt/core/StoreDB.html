<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of StoreDB</title>
  <meta name="keywords" content="StoreDB">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">manopt</a> &gt; <a href="index.html">core</a> &gt; StoreDB.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for manopt\core&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>StoreDB
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="handle_light.html" class="code" title="">handle_light</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="StoreDB.html" class="code" title="">StoreDB</a>	</li><li><a href="getApproxGradient.html" class="code" title="function approxgrad = getApproxGradient(problem, x, storedb, key)">getApproxGradient</a>	Computes an approximation of the gradient of the cost function at x.</li><li><a href="getApproxHessian.html" class="code" title="function approxhess = getApproxHessian(problem, x, d, storedb, key)">getApproxHessian</a>	Computes an approximation of the Hessian of the cost fun. at x along d.</li><li><a href="getCost.html" class="code" title="function cost = getCost(problem, x, storedb, key)">getCost</a>	Computes the cost function at x.</li><li><a href="getCostGrad.html" class="code" title="function [cost, grad] = getCostGrad(problem, x, storedb, key)">getCostGrad</a>	Computes the cost function and the gradient at x in one call if possible.</li><li><a href="getDirectionalDerivative.html" class="code" title="function diff = getDirectionalDerivative(problem, x, d, storedb, key)">getDirectionalDerivative</a>	Computes the directional derivative of the cost function at x along d.</li><li><a href="getEuclideanGradient.html" class="code" title="function egrad = getEuclideanGradient(problem, x, storedb, key)">getEuclideanGradient</a>	Computes the Euclidean gradient of the cost function at x.</li><li><a href="getGradient.html" class="code" title="function grad = getGradient(problem, x, storedb, key)">getGradient</a>	Computes the gradient of the cost function at x.</li><li><a href="getGradientFD.html" class="code" title="function gradfd = getGradientFD(problem, x, storedb, key)">getGradientFD</a>	Computes an approx. of the gradient w/ finite differences of the cost.</li><li><a href="getHessian.html" class="code" title="function hess = getHessian(problem, x, d, storedb, key)">getHessian</a>	Computes the Hessian of the cost function at x along d.</li><li><a href="getHessianFD.html" class="code" title="function hessfd = getHessianFD(problem, x, d, storedb, key)">getHessianFD</a>	Computes an approx. of the Hessian w/ finite differences of the gradient.</li><li><a href="getLinesearch.html" class="code" title="function t = getLinesearch(problem, x, d, storedb, key)">getLinesearch</a>	Returns a hint for line-search algorithms.</li><li><a href="getPartialEuclideanGradient.html" class="code" title="function egrad = getPartialEuclideanGradient(problem, x, I, storedb, key)">getPartialEuclideanGradient</a>	Computes the Euclidean gradient of a subset of terms in cost function.</li><li><a href="getPartialGradient.html" class="code" title="function grad = getPartialGradient(problem, x, I, storedb, key)">getPartialGradient</a>	Computes the gradient of a subset of terms in the cost function at x.</li><li><a href="getPrecon.html" class="code" title="function Pd = getPrecon(problem, x, d, storedb, key)">getPrecon</a>	Applies the preconditioner for the Hessian of the cost at x along d.</li><li><a href="getSqrtPrecon.html" class="code" title="function sqrtPd = getSqrtPrecon(problem, x, d, storedb, key)">getSqrtPrecon</a>	Applies the square root of the Hessian preconditioner at x along d.</li><li><a href="getSubgradient.html" class="code" title="function subgrad = getSubgradient(problem, x, tol, storedb, key)">getSubgradient</a>	Computes a subgradient of the cost function at x, up to a tolerance</li><li><a href="../../manopt/solvers/arc/arc.html" class="code" title="function [x, cost, info, options] = arc(problem, x, options)">arc</a>	Adaptive regularization by cubics (ARC) minimization algorithm for Manopt</li><li><a href="../../manopt/solvers/barzilaiborwein/barzilaiborwein.html" class="code" title="function [x, cost, info, options] = barzilaiborwein(problem, x, options)">barzilaiborwein</a>	Riemannian Barzilai-Borwein solver with non-monotone line-search.</li><li><a href="../../manopt/solvers/bfgs/rlbfgs.html" class="code" title="function [x, cost, info, options] = rlbfgs(problem, x0, options)">rlbfgs</a>	Riemannian limited memory BFGS solver for smooth objective functions.</li><li><a href="../../manopt/solvers/conjugategradient/conjugategradient.html" class="code" title="function [x, cost, info, options] = conjugategradient(problem, x, options)">conjugategradient</a>	Conjugate gradient minimization algorithm for Manopt.</li><li><a href="../../manopt/solvers/gradientapproximations/approxgradientFD.html" class="code" title="function gradfun = approxgradientFD(problem, options)">approxgradientFD</a>	Gradient approx. fnctn handle based on finite differences of the cost.</li><li><a href="../../manopt/solvers/hessianapproximations/approxhessianFD.html" class="code" title="function hessfun = approxhessianFD(problem, options)">approxhessianFD</a>	Hessian approx. fnctn handle based on finite differences of the gradient.</li><li><a href="../../manopt/solvers/linesearch/linesearch.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch(problem, x, d, f0, df0, options, storedb, key)">linesearch</a>	Standard line-search algorithm (step size selection) for descent methods.</li><li><a href="../../manopt/solvers/linesearch/linesearch_adaptive.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_adaptive(problem, x, d, f0, df0, options, storedb, key)">linesearch_adaptive</a>	Adaptive line search algorithm (step size selection) for descent methods.</li><li><a href="../../manopt/solvers/linesearch/linesearch_decrease.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_decrease(problem, x, d, f0, ~, options, storedb, key)">linesearch_decrease</a>	Backtracking line-search aiming merely for a decrease in cost value.</li><li><a href="../../manopt/solvers/linesearch/linesearch_hint.html" class="code" title="function [stepsize, newx, newkey, lsstats] =linesearch_hint(problem, x, d, f0, df0, options, storedb, key)">linesearch_hint</a>	Armijo line-search based on the line-search hint in the problem structure.</li><li><a href="../../manopt/solvers/neldermead/neldermead.html" class="code" title="function [x, cost, info, options] = neldermead(problem, x, options)">neldermead</a>	Nelder Mead optimization algorithm for derivative-free minimization.</li><li><a href="../../manopt/solvers/preconditioners/preconhessiansolve.html" class="code" title="function preconfun = preconhessiansolve(problem, options)">preconhessiansolve</a>	Preconditioner based on the inverse Hessian, by solving linear systems.</li><li><a href="../../manopt/solvers/pso/pso.html" class="code" title="function [xbest, fbest, info, options] = pso(problem, x, options)">pso</a>	Particle swarm optimization (PSO) for derivative-free minimization.</li><li><a href="../../manopt/solvers/steepestdescent/steepestdescent.html" class="code" title="function [x, cost, info, options] = steepestdescent(problem, x, options)">steepestdescent</a>	Steepest descent (gradient descent) minimization algorithm for Manopt.</li><li><a href="../../manopt/solvers/stochasticgradient/stepsize_sg.html" class="code" title="function [stepsize, newx, newkey, ssstats] =stepsize_sg(problem, x, d, iter, options, storedb, key) %#ok<INUSD>">stepsize_sg</a>	Standard step size selection algorithm for the stochastic gradient method</li><li><a href="../../manopt/solvers/stochasticgradient/stochasticgradient.html" class="code" title="function [x, info, options] = stochasticgradient(problem, x, options)">stochasticgradient</a>	Stochastic gradient (SG) minimization algorithm for Manopt.</li><li><a href="../../manopt/solvers/trustregions/trustregions.html" class="code" title="function [x, cost, info, options] = trustregions(problem, x, options)">trustregions</a>	Riemannian trust-regions solver for optimization on manifolds.</li><li><a href="../../manopt/tools/checkdiff.html" class="code" title="function checkdiff(problem, x, d, force_gradient)">checkdiff</a>	Checks the consistency of the cost function and directional derivatives.</li><li><a href="../../manopt/tools/checkgradient.html" class="code" title="function checkgradient(problem, x, d)">checkgradient</a>	Checks the consistency of the cost function and the gradient.</li><li><a href="../../manopt/tools/checkhessian.html" class="code" title="function checkhessian(problem, x, d)">checkhessian</a>	Checks the consistency of the cost function and the Hessian.</li><li><a href="../../manopt/tools/hessianextreme.html" class="code" title="function [y, lambda, info] = hessianextreme(problem, x, side, y0, options, storedb, key)">hessianextreme</a>	Compute an extreme eigenvector / eigenvalue of the Hessian of a problem.</li><li><a href="../../manopt/tools/hessianmatrix.html" class="code" title="function [H, basis] = hessianmatrix(problem, x, basis)">hessianmatrix</a>	Computes a matrix which represents the Hessian in some tangent basis.</li><li><a href="../../manopt/tools/hessianspectrum.html" class="code" title="function lambdas = hessianspectrum(problem, x, usepreconstr, storedb, key)">hessianspectrum</a>	Returns the eigenvalues of the (preconditioned) Hessian at x.</li><li><a href="../../manopt/tools/plotprofile.html" class="code" title="function cost = plotprofile(problem, x, d, t)">plotprofile</a>	Plot the cost function along a geodesic or a retraction path.</li><li><a href="../../manopt/tools/surfprofile.html" class="code" title="function costs = surfprofile(problem, x, d1, d2, t1, t2)">surfprofile</a>	Plot the cost function as a surface over a 2-dimensional subspace.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function storedb = StoreDB(storedepth)</a></li><li><a href="#_sub2" class="code">function store = get(storedb, key)</a></li><li><a href="#_sub3" class="code">function store = getWithShared(storedb, key)</a></li><li><a href="#_sub4" class="code">function key = set(storedb, store, key)</a></li><li><a href="#_sub5" class="code">function key = setWithShared(storedb, store, key)</a></li><li><a href="#_sub6" class="code">function remove(storedb, key)</a></li><li><a href="#_sub7" class="code">function removefirstifdifferent(storedb, key1, key2)</a></li><li><a href="#_sub8" class="code">function key = getNewKey(storedb)</a></li><li><a href="#_sub9" class="code">function purge(storedb)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="StoreDB.html" class="code" title="">StoreDB</a> &lt; <a href="handle_light.html" class="code" title="">handle_light</a>
0002 <span class="comment">% The StoreDB class is a handle class to manage caching in Manopt.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% To create an object, call: storedb = StoreDB();</span>
0005 <span class="comment">% Alternatively, call: storedb = StoreDB(storedepth); to instruct</span>
0006 <span class="comment">% the database to keep at most storedepth stores in its history.</span>
0007 <span class="comment">% (Note that clean up only happens when purge() is called).</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% The storedb object is passed by reference: when it is passed to a</span>
0010 <span class="comment">% function as an input, and that function modifies it, the original</span>
0011 <span class="comment">% object is modified.</span>
0012 
0013 <span class="comment">% This file is part of Manopt: www.manopt.org.</span>
0014 <span class="comment">% Original author: Nicolas Boumal, April 3, 2015.</span>
0015 <span class="comment">% Contributors:</span>
0016 <span class="comment">% Change log:</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%   Aug. 2, 2018 (NB)</span>
0019 <span class="comment">%       Purge now selects based on time since last access, whether read or</span>
0020 <span class="comment">%       write. It used to select based on last write. This should allow to</span>
0021 <span class="comment">%       set a smaller value of storedepth for trustregions (in particular).</span>
0022 <span class="comment">%       Also added StoreDB.remove(key) which allows to specifically remove</span>
0023 <span class="comment">%       the store associated to a key. This can be used by a solver when it</span>
0024 <span class="comment">%       is reasonably certain that the memory associated to a certain key</span>
0025 <span class="comment">%       is no longer needed (for example, when a step was rejected in</span>
0026 <span class="comment">%       trustregions or in a line-search algorithm.) Proper usage of this</span>
0027 <span class="comment">%       feature should allow to set a small value for storedepth.</span>
0028 <span class="comment">%       Furthermore, getNewKey() now places an empty store at the created</span>
0029 <span class="comment">%       key. As a result, it is no longer legitimate to call storedb.get on</span>
0030 <span class="comment">%       an unknown key: this now issues a warning, which should help debug.</span>
0031 <span class="comment">%       The function removefirstifdifferent(key1, key2) only removes key1</span>
0032 <span class="comment">%       if it is different from key2, which is helpful when an iteration</span>
0033 <span class="comment">%       may have failed to move to a distinct point.</span>
0034 
0035 <span class="comment">% TODO : protect get/setWithShared calls: limit to one, and forbid access</span>
0036 <span class="comment">%        to shared memory while it has not been returned.</span>
0037 <span class="comment">%        Do think of the applyStatsFun case : calls a getWithShared, does</span>
0038 <span class="comment">%        not need a setWithShared. I think for statsfun there should be a</span>
0039 <span class="comment">%        method &quot;forfeitWithShared&quot;.</span>
0040     
0041     properties(Access = public)
0042        
0043         <span class="comment">% This memory is meant to be shared at all times. Users can modify</span>
0044         <span class="comment">% this at will. It is the same for all points x.</span>
0045         shared = struct();
0046         
0047         <span class="comment">% This memory is used by the toolbox for, e.g., automatic caching</span>
0048         <span class="comment">% and book keeping. Users should not overwrite this. It is the</span>
0049         <span class="comment">% same for all points x.</span>
0050         internal = struct();
0051         
0052         <span class="comment">% When calling purge(), only a certain number of stores will be</span>
0053         <span class="comment">% kept in 'history'. This parameter fixes that number. The most</span>
0054         <span class="comment">% recently modified stores are kept. Set to inf to keep all stores.</span>
0055         storedepth = inf;
0056         
0057     <span class="keyword">end</span>
0058     
0059     properties(Access = private)
0060         
0061         <span class="comment">% This structure holds separate memories for individual points.</span>
0062         <span class="comment">% Use get and set to interact with this. The field name 'shared' is</span>
0063         <span class="comment">% reserved, for use with get/setWithShared.</span>
0064         history = struct();
0065         
0066         <span class="comment">% This internal counter is used to obtain unique key's for points.</span>
0067         counter = uint32(0);
0068         
0069         <span class="comment">% This internal counter is used to time calls to 'set', and hence</span>
0070         <span class="comment">% keep track of which stores in 'history' were last updated.</span>
0071         timer = uint32(0);
0072         
0073     <span class="keyword">end</span>
0074     
0075     
0076     methods(Access = public)
0077         
0078         <span class="comment">% Constructor</span>
0079         <a name="_sub0" href="#_subfunctions" class="code">function storedb = StoreDB(storedepth)</a>
0080             <span class="keyword">if</span> nargin &gt;= 1
0081                 storedb.storedepth = storedepth;
0082             <span class="keyword">end</span>
0083         <span class="keyword">end</span>
0084         
0085         <span class="comment">% Returns the store associated to a given key.</span>
0086         <span class="comment">% If the key is unknown, issues a warning and returns empty store.</span>
0087         <a name="_sub1" href="#_subfunctions" class="code">function store = get(storedb, key)</a>
0088             <span class="keyword">if</span> isfield(storedb.history, key)
0089                 <span class="comment">% Update access timer.</span>
0090                 storedb.history.(key).lastaccess__ = storedb.timer;
0091                 <span class="comment">% Extract the store.</span>
0092                 store = storedb.history.(key);
0093             <span class="keyword">else</span>
0094                 store = struct();
0095                 store.lastaccess__ = storedb.timer;
0096                 msg = <span class="string">'Called storedb.get for a store with unknown key.'</span>;
0097                 <span class="comment">% If the queried key is less than the counter, it must have</span>
0098                 <span class="comment">% been a valid key at some point. Inform the user that it</span>
0099                 <span class="comment">% may have been purged (or removed) prematurely.</span>
0100                 <span class="keyword">if</span> str2double(key(2:end)) &lt; storedb.counter
0101                     msg = [msg, <span class="string">' It seems that key was purged or removed.'</span>];
0102                 <span class="keyword">end</span>
0103                 msg = [msg, <span class="string">' Returned an empty structure.'</span>];
0104                 warning(<span class="string">'manopt:storedb:get'</span>, msg);
0105             <span class="keyword">end</span>
0106             storedb.timer = storedb.timer + 1;
0107         <span class="keyword">end</span>
0108         
0109         <span class="comment">% Same as get, but adds the shared memory in store.shared.</span>
0110         <a name="_sub2" href="#_subfunctions" class="code">function store = getWithShared(storedb, key)</a>
0111             store = storedb.get(key);
0112             store.shared = storedb.shared;
0113         <span class="keyword">end</span>
0114         
0115         <span class="comment">% Save the given store at the given key. If no key is provided, a</span>
0116         <span class="comment">% new key is generated for this store (i.e., it is assumed this</span>
0117         <span class="comment">% store pertains to a new point). The key is returned in all cases.</span>
0118         <span class="comment">% A field 'lastaccess__' is added/updated in the store structure,</span>
0119         <span class="comment">% keeping track of the last time that store was accessed.</span>
0120         <a name="_sub3" href="#_subfunctions" class="code">function key = set(storedb, store, key)</a>
0121             <span class="keyword">if</span> nargin &lt; 3
0122                 key = <a href="#_sub8" class="code" title="subfunction key = getNewKey(storedb)">getNewKey</a>(storedb);
0123             <span class="keyword">end</span>
0124             store.lastaccess__ = storedb.timer;
0125             storedb.timer = storedb.timer + 1;
0126             storedb.history.(key) = store;
0127         <span class="keyword">end</span>
0128         
0129         <span class="comment">% Same as set, but extracts the shared memory and saves it.</span>
0130         <span class="comment">% The stored store will still have a 'shared' field, but empty.</span>
0131         <a name="_sub4" href="#_subfunctions" class="code">function key = setWithShared(storedb, store, key)</a>
0132             storedb.shared = store.shared;
0133             store.shared = [];
0134             key = storedb.set(store, key);
0135         <span class="keyword">end</span>
0136         
0137         <span class="comment">% Erases a store from memory, identified by key.</span>
0138         <span class="comment">% If the key is unknown, issues a warning.</span>
0139         <a name="_sub5" href="#_subfunctions" class="code">function remove(storedb, key)</a>
0140             <span class="keyword">if</span> isfield(storedb.history, key)
0141                 storedb.history = rmfield(storedb.history, key);
0142             <span class="keyword">else</span>
0143                 warning(<span class="string">'manopt:storedb:remove'</span>, <span class="keyword">...</span>
0144                        [<span class="string">'Attempted to remove store with unknown key.\n'</span> <span class="keyword">...</span>
0145                         <span class="string">'Perhaps it was purged? Try postponing purge().'</span>]);
0146             <span class="keyword">end</span>
0147         <span class="keyword">end</span>
0148         
0149         <span class="comment">% Erases store at key1 if it is different from key2.</span>
0150         <a name="_sub6" href="#_subfunctions" class="code">function removefirstifdifferent(storedb, key1, key2)</a>
0151             <span class="keyword">if</span> ~strcmp(key1, key2)
0152                 storedb.remove(key1);
0153             <span class="keyword">end</span>
0154         <span class="keyword">end</span>
0155         
0156         <span class="comment">% Generates a unique key and returns it. This should be called</span>
0157         <span class="comment">% everytime a new point is generated / stored. Keys are valid field</span>
0158         <span class="comment">% names for structures. After this call, an empty store is added in</span>
0159         <span class="comment">% the cache at the newly generated key. It has minimal priority</span>
0160         <span class="comment">% vis-à-vis storedb.purge().</span>
0161         <a name="_sub7" href="#_subfunctions" class="code">function key = getNewKey(storedb)</a>
0162             key = sprintf(<span class="string">'z%d'</span>, storedb.counter);
0163             storedb.counter = storedb.counter + 1;
0164             <span class="comment">% If we attempt to storedb.remove(key) or storedb.get(key) on</span>
0165             <span class="comment">% this newly created key before anything is stored there, we</span>
0166             <span class="comment">% will get a warning. Since there are legitimate scenarios for</span>
0167             <span class="comment">% this to happen, we place an empty store at the new key</span>
0168             <span class="comment">% immediately. Its last-access flag is set to 0 so it would be</span>
0169             <span class="comment">% the first to be purged (unless it was later accessed.)</span>
0170             emptystore = struct();
0171             emptystore.lastaccess__ = 0;
0172             storedb.history.(key) = emptystore;
0173         <span class="keyword">end</span>
0174         
0175         <span class="comment">% Clear entries in storedb.history to limit memory usage.</span>
0176         <a name="_sub8" href="#_subfunctions" class="code">function purge(storedb)</a>
0177             
0178             <span class="keyword">if</span> isinf(storedb.storedepth)
0179                 <span class="keyword">return</span>;
0180             <span class="keyword">end</span>
0181             
0182             <span class="keyword">if</span> storedb.storedepth &lt;= 0
0183                 storedb.history = struct();
0184                 <span class="keyword">return</span>;
0185             <span class="keyword">end</span>
0186 
0187             <span class="comment">% Get list of field names (keys).</span>
0188             keys = fieldnames(storedb.history);
0189             nkeys = length(keys);
0190 
0191             <span class="comment">% If we need to remove some of the elements in the database,</span>
0192             <span class="keyword">if</span> nkeys &gt; storedb.storedepth
0193 
0194                 <span class="comment">% Get the last-access counter of each element:</span>
0195                 <span class="comment">% A higher number means it was accessed more recently.</span>
0196                 <span class="comment">% Both read and write operations are considered 'access'.</span>
0197                 lastaccess = zeros(nkeys, 1, class(storedb.timer));
0198                 <span class="keyword">for</span> i = 1 : nkeys
0199                     lastaccess(i) = storedb.history.(keys{i}).lastaccess__;
0200                 <span class="keyword">end</span>
0201 
0202                 <span class="comment">% Sort the counters and determine the threshold above which</span>
0203                 <span class="comment">% the field needs to be removed.</span>
0204                 sortlastaccess = sort(lastaccess, 1, <span class="string">'descend'</span>);
0205                 minlastaccess = sortlastaccess(storedb.storedepth);
0206 
0207                 <span class="comment">% Remove all fields that are too old.</span>
0208                 storedb.history = rmfield(storedb.history, <span class="keyword">...</span>
0209                                          keys(lastaccess &lt; minlastaccess));
0210             <span class="keyword">end</span>
0211             
0212         <span class="keyword">end</span> <span class="comment">% end of purge()</span>
0213         
0214     <span class="keyword">end</span>
0215     
0216 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 10-Sep-2018 11:48:06 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>